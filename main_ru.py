"""
Русский AI Телеграм Бот - Основное Приложение
============================================
Продвинутый русскоязычный Telegram бот с:
- ИИ чат с памятью диалога
- Генерация и анализ изображений  
- Голосовые сообщения (STT/TTS)
- Система платежей и подписок
- Админ панель и аналитика
- Напоминания и инструменты
"""

import asyncio
import json
import logging
import time
from contextlib import asynccontextmanager
from datetime import datetime, timedelta
from typing import Any, Dict, Optional

import structlog
import uvicorn
from fastapi import FastAPI, Request, Response, HTTPException, BackgroundTasks
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import JSONResponse

from config_ru import настройки
from database_ru import МенеджерБД
from telegram_ru import ТелеграмКлиент
from openai_ru import ОпенАИКлиент
from handlers_ru import ОбработчикСообщений
from admin_ru import АдминПанель
from payments_ru import МенеджерПлатежей
from analytics_ru import АналитикаДвижок

# Настройка структурированного логирования
structlog.configure(
    processors=[
        structlog.stdlib.filter_by_level,
        structlog.stdlib.add_logger_name,
        structlog.stdlib.add_log_level,
        structlog.stdlib.PositionalArgumentsFormatter(),
        structlog.processors.TimeStamper(fmt="iso"),
        structlog.processors.StackInfoRenderer(),
        structlog.processors.format_exc_info,
        structlog.processors.UnicodeDecoder(),
        structlog.processors.JSONRenderer()
    ],
    context_class=dict,
    logger_factory=structlog.stdlib.LoggerFactory(),
    wrapper_class=structlog.stdlib.BoundLogger,
    cache_logger_on_first_use=True,
)

лог = structlog.get_logger("главное_приложение")

# Глобальные экземпляры
менеджер_бд: МенеджерБД = None
телеграм_клиент: ТелеграмКлиент = None
опенаи_клиент: ОпенАИКлиент = None
обработчик_сообщений: ОбработчикСообщений = None
админ_панель: АдминПанель = None
менеджер_платежей: МенеджерПлатежей = None
аналитика_движок: АналитикаДвижок = None

# Фоновые задачи
фоновые_задачи_работают = True

@asynccontextmanager
async def жизненный_цикл_приложения(app: FastAPI):
    """Менеджер жизненного цикла приложения для запуска и остановки."""
    global менеджер_бд, телеграм_клиент, опенаи_клиент, обработчик_сообщений
    global админ_панель, менеджер_платежей, аналитика_движок
    
    лог.info("Запуск русского Telegram бота", версия=настройки.версия)
    
    try:
        # Инициализация базы данных
        менеджер_бд = МенеджерБД(настройки.база_данных.ссылка)
        await менеджер_бд.инициализировать()
        лог.info("База данных успешно инициализирована")
        
        # Инициализация клиентов
        телеграм_клиент = ТелеграмКлиент(настройки.телеграм.токен_бота, менеджер_бд)
        опенаи_клиент = ОпенАИКлиент(настройки.опенаи.апи_ключ, менеджер_бд)
        
        # Инициализация компонентов
        аналитика_движок = АналитикаДвижок(менеджер_бд)
        менеджер_платежей = МенеджерПлатежей(телеграм_клиент, менеджер_бд)
        админ_панель = АдминПанель(телеграм_клиент, менеджер_бд, аналитика_движок)
        
        # Инициализация обработчика сообщений
        обработчик_сообщений = ОбработчикСообщений(
            телеграм_клиент=телеграм_клиент,
            опенаи_клиент=опенаи_клиент,
            менеджер_бд=менеджер_бд,
            менеджер_платежей=менеджер_платежей,
            аналитика_движок=аналитика_движок
        )
        
        # Установка вебхука
        ссылка_вебхука = настройки.телеграм.полная_ссылка_вебхука
        if ссылка_вебхука:
            успех = await телеграм_клиент.установить_вебхук(ссылка_вебхука, настройки.телеграм.секрет_вебхука)
            if успех:
                лог.info("Вебхук успешно установлен", ссылка=ссылка_вебхука)
            else:
                лог.error("Не удалось установить вебхук", ссылка=ссылка_вебхука)
        else:
            лог.warning("Ссылка вебхука не настроена")
        
        # Запуск фоновых задач
        asyncio.create_task(работник_напоминаний())
        asyncio.create_task(работник_аналитики())
        asyncio.create_task(работник_обслуживания())
        
        лог.info("Приложение успешно запущено")
        
        yield
        
    except Exception as e:
        лог.error("Ошибка запуска приложения", ошибка=str(e))
        raise
    finally:
        # Очистка
        global фоновые_задачи_работают
        фоновые_задачи_работают = False
        
        if менеджер_бд:
            await менеджер_бд.закрыть()
            лог.info("Соединения с базой данных закрыты")
        
        лог.info("Завершение работы приложения")

# Создание FastAPI приложения
приложение = FastAPI(
    title="Русский AI Телеграм Бот",
    description="Продвинутый русскоязычный Telegram бот с ИИ, платежами и аналитикой",
    version=настройки.версия,
    lifespan=жизненный_цикл_приложения
)

# Добавление CORS middleware
приложение.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

@приложение.post("/webhook")
async def обработчик_вебхука(запрос: Request, фоновые_задачи: BackgroundTasks):
    """Обработка входящих обновлений Telegram webhook."""
    время_старта = time.perf_counter()
    
    try:
        # Проверка секрета вебхука
        if настройки.телеграм.секрет_вебхука:
            заголовок_секрета = запрос.headers.get("X-Telegram-Bot-Api-Secret-Token")
            if заголовок_секрета != настройки.телеграм.секрет_вебхука:
                лог.warning("Неверный секрет вебхука", ip=запрос.client.host)
                raise HTTPException(status_code=403, detail="Неверный секретный токен")
        
        # Парсинг обновления
        тело = await запрос.body()
        if not тело:
            raise HTTPException(status_code=400, detail="Пустое тело запроса")
        
        try:
            данные_обновления = json.loads(тело)
        except json.JSONDecodeError as e:
            лог.error("Неверный JSON в вебхуке", ошибка=str(e))
            raise HTTPException(status_code=400, detail="Неверный JSON")
        
        # Обработка обновления в фоне
        фоновые_задачи.add_task(обработать_обновление, данные_обновления, время_старта)
        
        return {"ok": True}
        
    except HTTPException:
        raise
    except Exception as e:
        лог.error("Ошибка обработчика вебхука", ошибка=str(e))
        raise HTTPException(status_code=500, detail="Внутренняя ошибка сервера")

async def обработать_обновление(данные_обновления: Dict[str, Any], время_старта: float):
    """Обработка Telegram обновления."""
    try:
        ид_обновления = данные_обновления.get("update_id")
        лог.info("Обработка обновления", ид_обновления=ид_обновления)
        
        # Запись аналитики
        if аналитика_движок:
            аналитика_движок.записать_начало_запроса()
        
        # Обработка разных типов обновлений
        if "message" in данные_обновления:
            await обработать_сообщение(данные_обновления["message"])
        elif "callback_query" in данные_обновления:
            await обработать_колбек_запрос(данные_обновления["callback_query"])
        elif "inline_query" in данные_обновления:
            await обработать_инлайн_запрос(данные_обновления["inline_query"])
        elif "pre_checkout_query" in данные_обновления:
            await обработать_предварительный_платеж(данные_обновления["pre_checkout_query"])
        elif "successful_payment" in данные_обновления:
            await обработать_успешный_платеж(данные_обновления["successful_payment"], данные_обновления["message"])
        else:
            лог.info("Необработанный тип обновления", ключи_обновления=list(данные_обновления.keys()))
        
        # Запись времени обработки
        длительность = time.perf_counter() - время_старта
        if аналитика_движок:
            аналитика_движок.записать_завершение_запроса(длительность, True)
        
        лог.info("Обновление успешно обработано", ид_обновления=ид_обновления, длительность=f"{длительность:.3f}с")
        
    except Exception as e:
        длительность = time.perf_counter() - время_старта
        лог.error("Ошибка обработки обновления", ошибка=str(e), длительность=f"{длительность:.3f}с")
        
        if аналитика_движок:
            аналитика_движок.записать_завершение_запроса(длительность, False)
            аналитика_движок.записать_ошибку("ошибка_обработки_обновления")

async def обработать_сообщение(сообщение: Dict[str, Any]):
    """Обработка входящего сообщения."""
    try:
        if not обработчик_сообщений:
            лог.error("Обработчик сообщений не инициализирован")
            return
        
        await обработчик_сообщений.обработать_сообщение(сообщение)
        
    except Exception as e:
        лог.error("Ошибка обработки сообщения", ошибка=str(e), ид_сообщения=сообщение.get("message_id"))
        
        # Отправка сообщения об ошибке пользователю
        ид_чата = сообщение.get("chat", {}).get("id")
        if ид_чата and телеграм_клиент:
            await телеграм_клиент.отправить_сообщение(
                ид_чата=ид_чата,
                текст="🔧 Произошла техническая ошибка. Попробуйте позже или обратитесь к администратору.",
                ответ_на_сообщение_ид=сообщение.get("message_id")
            )

async def обработать_колбек_запрос(колбек_запрос: Dict[str, Any]):
    """Обработка колбек запроса от инлайн клавиатур."""
    try:
        if not обработчик_сообщений:
            лог.error("Обработчик сообщений не инициализирован")
            return
        
        await обработчик_сообщений.обработать_колбек_запрос(колбек_запрос)
        
    except Exception as e:
        лог.error("Ошибка обработки колбек запроса", ошибка=str(e))
        
        # Ответ на колбек запрос с ошибкой
        ид_запроса = колбек_запрос.get("id")
        if ид_запроса and телеграм_клиент:
            await телеграм_клиент.ответить_на_колбек_запрос(
                ид_колбек_запроса=ид_запроса,
                текст="❌ Произошла ошибка. Попробуйте снова.",
                показать_уведомление=True
            )

async def обработать_инлайн_запрос(инлайн_запрос: Dict[str, Any]):
    """Обработка инлайн запроса."""
    try:
        if not обработчик_сообщений:
            лог.error("Обработчик сообщений не инициализирован")
            return
        
        await обработчик_сообщений.обработать_инлайн_запрос(инлайн_запрос)
        
    except Exception as e:
        лог.error("Ошибка обработки инлайн запроса", ошибка=str(e))

async def обработать_предварительный_платеж(предварительный_платеж: Dict[str, Any]):
    """Обработка предварительного запроса платежа."""
    try:
        if not менеджер_платежей:
            лог.error("Менеджер платежей не инициализирован")
            return
        
        await менеджер_платежей.обработать_предварительный_платеж(предварительный_платеж)
        
    except Exception as e:
        лог.error("Ошибка обработки предварительного платежа", ошибка=str(e))

async def обработать_успешный_платеж(платеж: Dict[str, Any], сообщение: Dict[str, Any]):
    """Обработка успешного платежа."""
    try:
        if not менеджер_платежей:
            лог.error("Менеджер платежей не инициализирован")
            return
        
        await менеджер_платежей.обработать_успешный_платеж(платеж, сообщение)
        
    except Exception as e:
        лог.error("Ошибка обработки успешного платежа", ошибка=str(e))

@приложение.get("/здоровье")
async def проверка_здоровья():
    """Эндпоинт проверки состояния системы."""
    try:
        # Проверка подключения к базе данных
        if менеджер_бд:
            await менеджер_бд.проверка_здоровья()
        
        # Проверка внешних сервисов
        статус_сервисов = {
            "база_данных": "здорова" if менеджер_бд else "не_инициализирована",
            "телеграм": "здоров" if телеграм_клиент else "не_инициализирован",
            "опенаи": "здоров" if опенаи_клиент else "не_инициализирован",
        }
        
        # Общее состояние
        все_здоровы = all(статус == "здорова" or статус == "здоров" for статус in статус_сервисов.values())
        
        return {
            "статус": "здоров" if все_здоровы else "деградировано",
            "время": datetime.utcnow().isoformat(),
            "версия": настройки.версия,
            "сервисы": статус_сервисов
        }
        
    except Exception as e:
        лог.error("Проверка здоровья не удалась", ошибка=str(e))
        return JSONResponse(
            status_code=503,
            content={
                "статус": "нездоров",
                "время": datetime.utcnow().isoformat(),
                "ошибка": str(e)
            }
        )

@приложение.get("/статистика")
async def получить_статистику():
    """Получение статистики бота (только для админов)."""
    try:
        if not аналитика_движок:
            raise HTTPException(status_code=503, detail="Аналитика недоступна")
        
        статистика = await аналитика_движок.получить_системную_статистику()
        return статистика
        
    except Exception as e:
        лог.error("Ошибка получения статистики", ошибка=str(e))
        raise HTTPException(status_code=500, detail="Не удалось получить статистику")

@приложение.get("/метрики")
async def получить_метрики():
    """Эндпоинт метрик Prometheus."""
    try:
        if not аналитика_движок:
            raise HTTPException(status_code=503, detail="Аналитика недоступна")
        
        метрики = await аналитика_движок.получить_метрики_прометеуса()
        return Response(content=метрики, media_type="text/plain")
        
    except Exception as e:
        лог.error("Ошибка получения метрик", ошибка=str(e))
        raise HTTPException(status_code=500, detail="Не удалось получить метрики")

# Фоновые рабочие функции
async def работник_напоминаний():
    """Фоновый работник для обработки напоминаний."""
    лог.info("Работник напоминаний запущен")
    
    while фоновые_задачи_работают:
        try:
            if менеджер_бд and телеграм_клиент:
                # Получение просроченных напоминаний
                напоминания = await менеджер_бд.получить_просроченные_напоминания()
                
                for напоминание in напоминания:
                    try:
                        # Отправка напоминания
                        await телеграм_клиент.отправить_сообщение(
                            ид_чата=напоминание["ид_чата"],
                            текст=f"⏰ Напоминание: {напоминание['задача']}",
                            режим_разметки="HTML"
                        )
                        
                        # Отметка как отправленное
                        await менеджер_бд.отметить_напоминание_отправленным(напоминание["id"])
                        
                        лог.info("Напоминание отправлено", ид_напоминания=напоминание["id"])
                        
                    except Exception as e:
                        лог.error("Не удалось отправить напоминание", 
                                ид_напоминания=напоминание.get("id"), ошибка=str(e))
            
            # Сон на 1 минуту
            await asyncio.sleep(60)
            
        except Exception as e:
            лог.error("Ошибка в работнике напоминаний", ошибка=str(e))
            await asyncio.sleep(60)

async def работник_аналитики():
    """Фоновый работник для сбора аналитики."""
    лог.info("Работник аналитики запущен")
    
    while фоновые_задачи_работают:
        try:
            if аналитика_движок:
                # Сбор метрик
                await аналитика_движок.собрать_системные_метрики()
                
                # Очистка старых данных
                await аналитика_движок.очистить_старые_данные()
                
                лог.debug("Метрики аналитики собраны")
            
            # Сон на 5 минут
            await asyncio.sleep(300)
            
        except Exception as e:
            лог.error("Ошибка в работнике аналитики", ошибка=str(e))
            await asyncio.sleep(300)

async def работник_обслуживания():
    """Фоновый работник для задач обслуживания."""
    лог.info("Работник обслуживания запущен")
    
    while фоновые_задачи_работают:
        try:
            if менеджер_бд:
                # Очистка старых сессий
                await менеджер_бд.очистить_старые_сессии()
                
                # Очистка старой истории разговоров
                await менеджер_бд.очистить_старые_разговоры()
                
                # Вакуум базы данных
                await менеджер_бд.вакуум_базы_данных()
                
                лог.debug("Задачи обслуживания выполнены")
            
            # Сон на 1 час
            await asyncio.sleep(3600)
            
        except Exception as e:
            лог.error("Ошибка в работнике обслуживания", ошибка=str(e))
            await asyncio.sleep(3600)

if __name__ == "__main__":
    # Настройка логирования
    logging.basicConfig(
        level=getattr(logging, настройки.уровень_лога.upper()),
        format="%(asctime)s - %(name)s - %(levelname)s - %(message)s"
    )
    
    # Запуск приложения
    uvicorn.run(
        "main_ru:приложение",
        host="0.0.0.0",
        port=int(настройки.порт),
        reload=настройки.отладка,
        access_log=настройки.отладка,
        log_level=настройки.уровень_лога.lower()
    )