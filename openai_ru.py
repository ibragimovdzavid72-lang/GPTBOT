"""Русский OpenAI Клиент с Локализацией"""

import time
from io import BytesIO
from typing import Any, Dict, List, Optional, Union

import structlog
from openai import AsyncOpenAI
from config_ru import настройки

лог = structlog.get_logger("опенаи")


class ОпенАИКлиент:
    """Русифицированный OpenAI API клиент."""
    
    def __init__(self, апи_ключ: str, менеджер_бд=None):
        self.клиент = AsyncOpenAI(
            api_key=апи_ключ,
            timeout=настройки.опенаи.таймаут,
            max_retries=настройки.опенаи.максимальных_повторов
        )
        self.менеджер_бд = менеджер_бд
        
        # Русские системные промпты
        self.системный_промпт = """Ты — умный русскоязычный ИИ-помощник в Telegram боте. 

ВАЖНЫЕ ПРАВИЛА:
- Всегда отвечай ТОЛЬКО на русском языке
- Будь дружелюбным, полезным и вежливым
- Давай точные и информативные ответы
- Используй смайлики для улучшения настроения
- Если не знаешь ответ, честно скажи об этом
- Помни контекст разговора
- Отвечай кратко, но полно"""
    
    async def закрыть(self):
        """Закрыть соединения клиента."""
        await self.клиент.close()
    
    # Чат-комплишн методы
    async def завершение_чата(
        self,
        сообщения: List[Dict[str, str]],
        ид_пользователя: Optional[int] = None,
        использовать_инструменты: bool = True,
        температура: float = None,
        макс_токенов: int = None,
        модель: str = None
    ) -> Dict[str, Any]:
        """Генерировать завершение чата с русскими промптами."""
        время_старта = time.perf_counter()
        
        try:
            # Подготовка параметров
            параметры = {
                "model": модель or настройки.опенаи.модель_чата,
                "messages": [{"role": "system", "content": self.системный_промпт}] + сообщения,
                "temperature": температура or настройки.опенаи.температура,
                "max_tokens": макс_токенов or настройки.опенаи.максимальных_токенов
            }
            
            # Выполнить API вызов
            ответ = await self.клиент.chat.completions.create(**параметры)
            
            # Обработать ответ
            сообщение = ответ.choices[0].message
            результат = {
                "содержимое": сообщение.content,
                "использование": dict(ответ.usage),
                "модель": ответ.model,
                "причина_завершения": ответ.choices[0].finish_reason
            }
            
            # Запись производительности
            длительность = time.perf_counter() - время_старта
            лог.info("Завершение чата успешно", 
                    модель=результат["модель"], 
                    токены=результат["использование"]["total_tokens"],
                    длительность=f"{длительность:.3f}с")
            
            return результат
            
        except Exception as e:
            длительность = time.perf_counter() - время_старта
            лог.error("Завершение чата не удалось", ошибка=str(e), длительность=f"{длительность:.3f}с")
            
            # Попробовать резервную модель
            if модель != настройки.опенаи.резервная_модель:
                лог.info("Пробую резервную модель")
                return await self.завершение_чата(
                    сообщения=сообщения,
                    ид_пользователя=ид_пользователя,
                    использовать_инструменты=False,
                    температура=температура,
                    макс_токенов=макс_токенов,
                    модель=настройки.опенаи.резервная_модель
                )
            
            raise
    
    # Генерация изображений
    async def сгенерировать_изображение(
        self,
        промпт: str,
        размер: str = "1024x1024",
        качество: str = "standard",
        стиль: str = "vivid",
        ид_пользователя: Optional[int] = None
    ) -> Dict[str, Any]:
        """Сгенерировать изображение с DALL-E 3."""
        время_старта = time.perf_counter()
        
        try:
            # Улучшить промпт для лучших результатов
            улучшенный_промпт = f"Высококачественное детализированное изображение: {промпт}. Русский стиль, красивые цвета, профессиональное исполнение."
            
            ответ = await self.клиент.images.generate(
                model=настройки.опенаи.модель_изображений,
                prompt=улучшенный_промпт,
                size=размер,
                quality=качество,
                style=стиль,
                n=1
            )
            
            ссылка_изображения = ответ.data[0].url
            пересмотренный_промпт = ответ.data[0].revised_prompt
            
            длительность = time.perf_counter() - время_старта
            лог.info("Генерация изображения успешна", 
                    длина_промпта=len(промпт),
                    длительность=f"{длительность:.3f}с")
            
            return {
                "ссылка": ссылка_изображения,
                "пересмотренный_промпт": пересмотренный_промпт,
                "размер": размер,
                "качество": качество,
                "стиль": стиль
            }
            
        except Exception as e:
            длительность = time.perf_counter() - время_старта
            лог.error("Генерация изображения не удалась", ошибка=str(e), длительность=f"{длительность:.3f}с")
            raise
    
    # Анализ изображений
    async def анализировать_изображение(
        self,
        данные_изображения: Union[str, bytes],
        промпт: str = "Подробно опиши это изображение на русском языке",
        макс_токенов: int = 500
    ) -> str:
        """Проанализировать изображение с GPT-4 Vision."""
        время_старта = time.perf_counter()
        
        try:
            # Конвертировать изображение в base64 если нужно
            if isinstance(данные_изображения, bytes):
                import base64
                изображение_base64 = base64.b64encode(данные_изображения).decode('utf-8')
                ссылка_изображения = f"data:image/jpeg;base64,{изображение_base64}"
            else:
                ссылка_изображения = данные_изображения
            
            # Русский промпт для анализа
            русский_промпт = f"Ты — эксперт по анализу изображений. {промпт}. Отвечай ТОЛЬКО на русском языке, будь подробным и точным."
            
            ответ = await self.клиент.chat.completions.create(
                model=настройки.опенаи.модель_видения,
                messages=[
                    {
                        "role": "user",
                        "content": [
                            {"type": "text", "text": русский_промпт},
                            {
                                "type": "image_url",
                                "image_url": {"url": ссылка_изображения}
                            }
                        ]
                    }
                ],
                max_tokens=макс_токенов
            )
            
            результат = ответ.choices[0].message.content
            
            длительность = time.perf_counter() - время_старта
            лог.info("Анализ изображения успешен", длительность=f"{длительность:.3f}с")
            
            return результат
            
        except Exception as e:
            длительность = time.perf_counter() - время_старта
            лог.error("Анализ изображения не удался", ошибка=str(e), длительность=f"{длительность:.3f}с")
            raise
    
    # Обработка речи
    async def речь_в_текст(self, аудио_данные: bytes, язык: str = "ru") -> str:
        """Конвертировать речь в текст используя Whisper."""
        время_старта = time.perf_counter()
        
        try:
            # Создать объект аудио файла
            аудио_файл = BytesIO(аудио_данные)
            аудио_файл.name = "аудио.ogg"
            
            ответ = await self.клиент.audio.transcriptions.create(
                model=настройки.опенаи.модель_распознавания,
                file=аудио_файл,
                language=язык,
                prompt="Это русская речь. Распознай точно и без ошибок."
            )
            
            результат = ответ.text
            
            длительность = time.perf_counter() - время_старта
            лог.info("Речь в текст успешно", 
                    длина_текста=len(результат),
                    длительность=f"{длительность:.3f}с")
            
            return результат
            
        except Exception as e:
            длительность = time.perf_counter() - время_старта
            лог.error("Речь в текст не удалось", ошибка=str(e), длительность=f"{длительность:.3f}с")
            raise
    
    async def текст_в_речь(
        self,
        текст: str,
        голос: str = "alloy",
        скорость: float = 1.0
    ) -> bytes:
        """Конвертировать текст в речь используя TTS."""
        время_старта = time.perf_counter()
        
        try:
            # Оптимизировать текст для русского TTS
            оптимизированный_текст = текст.replace("ё", "е")  # TTS лучше работает с "е"
            
            ответ = await self.клиент.audio.speech.create(
                model=настройки.опенаи.модель_озвучки,
                voice=голос,
                input=оптимизированный_текст,
                speed=скорость
            )
            
            аудио_данные = ответ.content
            
            длительность = time.perf_counter() - время_старта
            лог.info("Текст в речь успешно", 
                    длина_текста=len(текст),
                    длительность=f"{длительность:.3f}с")
            
            return аудио_данные
            
        except Exception as e:
            длительность = time.perf_counter() - время_старта
            лог.error("Текст в речь не удалось", ошибка=str(e), длительность=f"{длительность:.3f}с")
            raise
    
    # Модерация контента
    async def модерировать_контент(self, текст: str) -> Dict[str, Any]:
        """Проверить контент на нарушения политики."""
        try:
            ответ = await self.клиент.moderations.create(input=текст)
            
            результат = ответ.results[0]
            
            return {
                "помечено": результат.flagged,
                "категории": dict(результат.categories),
                "оценки_категорий": dict(результат.category_scores)
            }
            
        except Exception as e:
            лог.error("Модерация контента не удалась", ошибка=str(e))
            # Вернуть безопасный результат при ошибке
            return {
                "помечено": False,
                "категории": {},
                "оценки_категорий": {}
            }