"""Русский Telegram API Клиент"""

import asyncio
import json
import time
from io import BytesIO
from typing import Any, Dict, List, Optional, Union
from urllib.parse import urljoin

import httpx
import structlog
from config_ru import настройки, получить_текст

лог = structlog.get_logger("телеграм")


class ОшибкаТелеграмАПИ(Exception):
    """Ошибка Telegram API."""
    pass


class ТелеграмКлиент:
    """Продвинутый русский Telegram Bot API клиент."""
    
    def __init__(self, токен_бота: str, менеджер_бд=None):
        self.токен_бота = токен_бота
        self.менеджер_бд = менеджер_бд
        self.базовая_ссылка = f"https://api.telegram.org/bot{токен_бота}/"
        
        # HTTP клиент с повторами и таймаутами
        self.http_клиент = httpx.AsyncClient(
            timeout=httpx.Timeout(настройки.телеграм.таймаут),
            limits=httpx.Limits(max_connections=настройки.телеграм.макс_соединений)
        )
        
        # Ограничение скорости
        self._время_последнего_запроса = 0
        self._счетчик_запросов = 0
        self._окно_ограничения_скорости = 60  # секунды
        self._макс_запросов_в_минуту = 30
    
    async def закрыть(self):
        """Закрыть HTTP клиент."""
        await self.http_клиент.aclose()
    
    async def _сделать_запрос(self, метод: str, **kwargs) -> Dict[str, Any]:
        """Сделать API запрос с ограничением скорости и обработкой ошибок."""
        await self._ограничить_скорость()
        
        ссылка = urljoin(self.базовая_ссылка, метод)
        
        for попытка in range(3):  # Повторить до 3 раз
            try:
                ответ = await self.http_клиент.post(ссылка, **kwargs)
                
                if ответ.status_code == 200:
                    данные = ответ.json()
                    if данные.get("ok"):
                        return данные["result"]
                    else:
                        код_ошибки = данные.get("error_code", 0)
                        описание = данные.get("description", "Неизвестная ошибка")
                        
                        # Обработка специфичных ошибок
                        if код_ошибки == 429:  # Слишком много запросов
                            повторить_через = данные.get("parameters", {}).get("retry_after", 1)
                            лог.warning("Ограничение скорости, ожидание", повторить_через=повторить_через)
                            await asyncio.sleep(повторить_через)
                            continue
                        
                        raise ОшибкаТелеграмАПИ(f"API Ошибка {код_ошибки}: {описание}")
                else:
                    лог.error("HTTP ошибка", статус_код=ответ.status_code, текст=ответ.text)
                    raise ОшибкаТелеграмАПИ(f"HTTP {ответ.status_code}: {ответ.text}")
                    
            except httpx.TimeoutException:
                лог.warning("Таймаут запроса", попытка=попытка + 1)
                if попытка == 2:  # Последняя попытка
                    raise ОшибкаТелеграмАПИ("Таймаут запроса")
                await asyncio.sleep(2 ** попытка)  # Экспоненциальная задержка
                
            except Exception as e:
                лог.error("Запрос не удался", ошибка=str(e), попытка=попытка + 1)
                if попытка == 2:  # Последняя попытка
                    raise
                await asyncio.sleep(2 ** попытка)
    
    async def _ограничить_скорость(self):
        """Реализовать ограничение скорости."""
        текущее_время = time.time()
        
        # Сбросить счетчик если окно прошло
        if текущее_время - self._время_последнего_запроса > self._окно_ограничения_скорости:
            self._счетчик_запросов = 0
            self._время_последнего_запроса = текущее_время
        
        # Проверить нужно ли ждать
        if self._счетчик_запросов >= self._макс_запросов_в_минуту:
            время_сна = self._окно_ограничения_скорости - (текущее_время - self._время_последнего_запроса)
            if время_сна > 0:
                лог.info("Ограничение скорости активно", время_сна=время_сна)
                await asyncio.sleep(время_сна)
                self._счетчик_запросов = 0
                self._время_последнего_запроса = time.time()
        
        self._счетчик_запросов += 1
    
    # Основные API методы
    async def установить_вебхук(self, ссылка: str, секретный_токен: Optional[str] = None) -> bool:
        """Установить ссылку вебхука."""
        параметры = {"url": ссылка}
        if секретный_токен:
            параметры["secret_token"] = секретный_токен
        
        результат = await self._сделать_запрос("setWebhook", json=параметры)
        return True
    
    # Методы отправки сообщений
    async def отправить_сообщение(
        self,
        ид_чата: Union[int, str],
        текст: str,
        режим_разметки: Optional[str] = "HTML",
        отключить_предпросмотр_веб_страниц: bool = True,
        отключить_уведомление: bool = False,
        ответ_на_сообщение_ид: Optional[int] = None,
        разметка_ответа: Optional[Dict] = None
    ) -> Dict[str, Any]:
        """Отправить текстовое сообщение."""
        # Разделить длинные сообщения
        if len(текст) > 4096:
            сообщения = []
            for i in range(0, len(текст), 4096):
                часть = текст[i:i+4096]
                сообщение = await self.отправить_сообщение(
                    ид_чата=ид_чата,
                    текст=часть,
                    режим_разметки=режим_разметки,
                    отключить_предпросмотр_веб_страниц=отключить_предпросмотр_веб_страниц,
                    отключить_уведомление=отключить_уведомление,
                    ответ_на_сообщение_ид=ответ_на_сообщение_ид if i == 0 else None,
                    разметка_ответа=разметка_ответа if i == 0 else None
                )
                сообщения.append(сообщение)
            return сообщения[0]  # Вернуть первое сообщение
        
        параметры = {
            "chat_id": ид_чата,
            "text": текст,
            "parse_mode": режим_разметки,
            "disable_web_page_preview": отключить_предпросмотр_веб_страниц,
            "disable_notification": отключить_уведомление
        }
        
        if ответ_на_сообщение_ид:
            параметры["reply_to_message_id"] = ответ_на_сообщение_ид
        
        if разметка_ответа:
            параметры["reply_markup"] = разметка_ответа
        
        return await self._сделать_запрос("sendMessage", json=параметры)
    
    async def отправить_фото(
        self,
        ид_чата: Union[int, str],
        фото: Union[str, BytesIO, bytes],
        подпись: Optional[str] = None,
        режим_разметки: Optional[str] = "HTML",
        ответ_на_сообщение_ид: Optional[int] = None,
        разметка_ответа: Optional[Dict] = None
    ) -> Dict[str, Any]:
        """Отправить фото."""
        параметры = {
            "chat_id": ид_чата,
            "parse_mode": режим_разметки
        }
        
        if подпись:
            параметры["caption"] = подпись
        if ответ_на_сообщение_ид:
            параметры["reply_to_message_id"] = ответ_на_сообщение_ид
        if разметка_ответа:
            параметры["reply_markup"] = json.dumps(разметка_ответа)
        
        # Обработать разные типы фото
        if isinstance(фото, str):
            # URL или file_id
            параметры["photo"] = фото
            return await self._сделать_запрос("sendPhoto", data=параметры)
        else:
            # Загрузка файла
            if isinstance(фото, bytes):
                фото = BytesIO(фото)
            
            файлы = {"photo": ("фото.jpg", фото, "image/jpeg")}
            return await self._сделать_запрос("sendPhoto", data=параметры, files=файлы)
    
    # Методы клавиатуры
    def создать_инлайн_клавиатуру(self, кнопки: List[List[Dict[str, str]]]) -> Dict[str, Any]:
        """Создать разметку инлайн клавиатуры."""
        return {
            "inline_keyboard": кнопки
        }
    
    def получить_главное_меню_клавиатуру(self, язык_пользователя: str = "ru", это_админ: bool = False) -> Dict[str, Any]:
        """Получить главное меню - ИСПРАВЛЕННАЯ ВЕРСИЯ."""
        кнопки = [
            [
                {"text": "💬 Умный чат", "callback_data": "функция:чат"},
                {"text": "🎨 Создать арт", "callback_data": "функция:арт"}
            ],
            [
                {"text": "🧙‍♂️ AI Персоны", "callback_data": "персоны:меню"},
                {"text": "👁️ Анализ фото", "callback_data": "функция:анализ"}
            ],
            [
                {"text": "🛠️ Инструменты", "callback_data": "инструменты:меню"},
                {"text": "🎮 Игры", "callback_data": "игры:меню"}
            ],
            [
                {"text": "📊 Статистика", "callback_data": "статистика:мой"},
                {"text": "⚙️ Настройки", "callback_data": "настройки:меню"}
            ]
        ]
        
        # Добавить премиум кнопку
        кнопки.append([
            {"text": "💎 Премиум", "callback_data": "премиум:тарифы"}
        ])
        
        # Админ кнопки
        if это_админ:
            кнопки.append([
                {"text": "🛡️ Админ", "callback_data": "админ:меню"}
            ])
        
        return {
            "inline_keyboard": кнопки
        }
    
    def получить_клавиатуру_инструментов(self, язык_пользователя: str = "ru") -> Dict[str, Any]:
        """Получить клавиатуру инструментов."""
        кнопки = [
            [
                {"text": "🌤️ Погода", "callback_data": "инструмент_погода"},
                {"text": "📚 Wikipedia", "callback_data": "инструмент_вики"}
            ],
            [
                {"text": "🧮 Калькулятор", "callback_data": "инструмент_калькулятор"},
                {"text": "🔤 Переводчик", "callback_data": "инструмент_переводчик"}
            ],
            [
                {"text": "⏰ Напоминания", "callback_data": "инструмент_напоминания"},
                {"text": "📊 QR-код", "callback_data": "инструмент_qr"}
            ],
            [
                {"text": "🔙 Назад", "callback_data": "главное_меню"}
            ]
        ]
        
        return {
            "inline_keyboard": кнопки
        }
    
    def получить_клавиатуру_подписки(self, язык_пользователя: str = "ru") -> Dict[str, Any]:
        """Получить клавиатуру подписки."""
        кнопки = [
            [
                {"text": "💎 Посмотреть тарифы", "callback_data": "премиум:тарифы"}
            ],
            [
                {"text": "🔙 Назад", "callback_data": "главное_меню"}
            ]
        ]
        
        return {
            "inline_keyboard": кнопки
        }
    
    # Новые методы для улучшенного опыта пользователя
    
    async def печатает(self, ид_чата: Union[int, str]):
        """Отправить действие 'печатает'."""
        await self.отправить_действие_чата(ид_чата, "typing")
    
    async def загружает_фото(self, ид_чата: Union[int, str]):
        """Отправить действие 'загружает фото'."""
        await self.отправить_действие_чата(ид_чата, "upload_photo")
    
    async def отправить_действие_чата(self, ид_чата: Union[int, str], действие: str):
        """Отправить действие в чат."""
        await self._сделать_запрос("sendChatAction", json={
            "chat_id": ид_чата,
            "action": действие
        })
    
    async def редактировать_текст_сообщения(
        self,
        ид_чата: Union[int, str],
        ид_сообщения: int,
        текст: str,
        режим_разметки: Optional[str] = "HTML",
        разметка_ответа: Optional[Dict] = None
    ):
        """Редактировать текст сообщения."""
        параметры = {
            "chat_id": ид_чата,
            "message_id": ид_сообщения,
            "text": текст,
            "parse_mode": режим_разметки
        }
        
        if разметка_ответа:
            параметры["reply_markup"] = разметка_ответа
        
        return await self._сделать_запрос("editMessageText", json=параметры)
    
    async def ответить_на_колбек_запрос(
        self,
        ид_колбек_запроса: str,
        текст: Optional[str] = None,
        показать_уведомление: bool = False
    ):
        """Ответить на колбек запрос."""
        параметры = {
            "callback_query_id": ид_колбек_запроса,
            "show_alert": показать_уведомление
        }
        
        if текст:
            параметры["text"] = текст
        
        return await self._сделать_запрос("answerCallbackQuery", json=параметры)
    
    def получить_главное_меню_клавиатуру(self, язык_пользователя: str = "ru", это_админ: bool = False) -> Dict[str, Any]:
        """Получить инлайн клавиатуру главного меню."""
        кнопки = [
            [
                {"text": получить_текст("кнопка_чат", язык_пользователя), "callback_data": "главное_чат"},
                {"text": получить_текст("кнопка_изображения", язык_пользователя), "callback_data": "главное_изображения"}
            ],
            [
                {"text": получить_текст("кнопка_голос", язык_пользователя), "callback_data": "главное_голос"},
                {"text": получить_текст("кнопка_инструменты", язык_пользователя), "callback_data": "главное_инструменты"}
            ],
            [
                {"text": получить_текст("кнопка_настройки", язык_пользователя), "callback_data": "главное_настройки"},
                {"text": получить_текст("кнопка_помощь", язык_пользователя), "callback_data": "главное_помощь"}
            ]
        ]
        
        if это_админ:
            кнопки.append([
                {"text": получить_текст("кнопка_админ", язык_пользователя), "callback_data": "админ_панель"}
            ])
        
        return self.создать_инлайн_клавиатуру(кнопки)
    
    def получить_клавиатуру_инструментов(self, язык_пользователя: str = "ru") -> Dict[str, Any]:
        """Получить инлайн клавиатуру инструментов."""
        кнопки = [
            [
                {"text": получить_текст("кнопка_погода", язык_пользователя), "callback_data": "инструмент_погода"},
                {"text": получить_текст("кнопка_википедия", язык_пользователя), "callback_data": "инструмент_википедия"}
            ],
            [
                {"text": получить_текст("кнопка_калькулятор", язык_пользователя), "callback_data": "инструмент_калькулятор"},
                {"text": получить_текст("кнопка_напоминания", язык_пользователя), "callback_data": "инструмент_напоминания"}
            ]
        ]
        
        if настройки.функции.включить_переводчик:
            кнопки.append([
                {"text": получить_текст("кнопка_переводчик", язык_пользователя), "callback_data": "инструмент_переводчик"}
            ])
        
        кнопки.append([
            {"text": получить_текст("кнопка_назад", язык_пользователя), "callback_data": "главное_меню"}
        ])
        
        return self.создать_инлайн_клавиатуру(кнопки)
    
    def получить_клавиатуру_подписки(self, язык_пользователя: str = "ru") -> Dict[str, Any]:
        """Получить клавиатуру вариантов подписки."""
        кнопки = [
            [
                {"text": "💎 Про - 500₽/мес", "callback_data": "подписаться_про"},
                {"text": "👑 Команда - 1500₽/мес", "callback_data": "подписаться_команда"}
            ],
            [
                {"text": получить_текст("кнопка_назад", язык_пользователя), "callback_data": "главное_настройки"}
            ]
        ]
        
        return self.создать_инлайн_клавиатуру(кнопки)
    
    # Методы действий чата
    async def отправить_действие_чата(self, ид_чата: Union[int, str], действие: str):
        """Отправить действие чата (печатает, загружает_фото и т.д.)."""
        параметры = {
            "chat_id": ид_чата,
            "action": действие
        }
        
        try:
            await self._сделать_запрос("sendChatAction", json=параметры)
        except Exception as e:
            лог.warning("Не удалось отправить действие чата", ошибка=str(e))
    
    async def печатает(self, ид_чата: Union[int, str]):
        """Отправить действие печатает."""
        await self.отправить_действие_чата(ид_чата, "typing")
    
    async def загружает_фото(self, ид_чата: Union[int, str]):
        """Отправить действие загружает фото."""
        await self.отправить_действие_чата(ид_чата, "upload_photo")
    
    # Методы колбек запросов
    async def ответить_на_колбек_запрос(
        self,
        ид_колбек_запроса: str,
        текст: Optional[str] = None,
        показать_уведомление: bool = False,
        ссылка: Optional[str] = None
    ) -> bool:
        """Ответить на колбек запрос."""
        параметры = {
            "callback_query_id": ид_колбек_запроса,
            "show_alert": показать_уведомление
        }
        
        if текст:
            параметры["text"] = текст
        if ссылка:
            параметры["url"] = ссылка
        
        await self._сделать_запрос("answerCallbackQuery", json=параметры)
        return True
    
    # Методы редактирования сообщений
    async def редактировать_текст_сообщения(
        self,
        ид_чата: Union[int, str],
        ид_сообщения: int,
        текст: str,
        режим_разметки: Optional[str] = "HTML",
        разметка_ответа: Optional[Dict] = None
    ) -> Dict[str, Any]:
        """Редактировать текст сообщения."""
        параметры = {
            "chat_id": ид_чата,
            "message_id": ид_сообщения,
            "text": текст,
            "parse_mode": режим_разметки
        }
        
        if разметка_ответа:
            параметры["reply_markup"] = разметка_ответа
        
        return await self._сделать_запрос("editMessageText", json=параметры)